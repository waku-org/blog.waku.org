"use strict";(self.webpackChunkblog_waku_org=self.webpackChunkblog_waku_org||[]).push([[8437],{59692:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>p});var a=n(87462),o=(n(67294),n(3905)),i=n(31665);const s={layout:"post",name:"Build a dApp Using Waku and Vue.js",title:"Build a dApp Using Waku and Vue.js",date:new Date("2024-03-04T00:00:00.000Z"),authors:"joel",published:null,slug:"build-dapps-using-waku",image:"/img/black-waku-logo-with-name.png",sidebar_class_name:"hidden"},r=void 0,l={permalink:"/build-dapps-using-waku",source:"@site/posts/build-dapps-using-waku-and-vue-js.mdx",title:"Build a dApp Using Waku and Vue.js",description:"Read in Spanish",date:"2024-03-04T00:00:00.000Z",formattedDate:"March 4, 2024",tags:[],readingTime:19.725,hasTruncateMarker:!0,authors:[{name:"Joel Adewole",twitter:"@wolz_codelife",github:"wolz-CODElife",key:"joel"}],frontMatter:{layout:"post",name:"Build a dApp Using Waku and Vue.js",title:"Build a dApp Using Waku and Vue.js",date:"2024-03-04T00:00:00.000Z",authors:"joel",published:null,slug:"build-dapps-using-waku",image:"/img/black-waku-logo-with-name.png",sidebar_class_name:"hidden"},prevItem:{title:"The convergence of AI, Blockchain and Privacy",permalink:"/convergence-of-ai-blockchain-privacy"},nextItem:{title:"February EcoDev Roundup",permalink:"/february-roundup"}},u={authorsImageUrls:[void 0]},p=[{value:"<strong>Understanding Waku</strong>",id:"understanding-waku",level:2},{value:"<strong>Use cases of Waku</strong>",id:"use-cases-of-waku",level:2},{value:"<strong>Privacy-focused communication</strong>",id:"privacy-focused-communication",level:4},{value:"<strong>Censorship-resistant messaging</strong>",id:"censorship-resistant-messaging",level:4},{value:"<strong>Use in dApps for decentralised communication</strong>",id:"use-in-dapps-for-decentralised-communication",level:4},{value:"<strong>Building a dApp with Waku and Vue.js</strong>",id:"building-a-dapp-with-waku-and-vuejs",level:2},{value:"<strong>Dev tools I used?</strong>",id:"dev-tools-i-used",level:3},{value:"<strong>Setting up the development environment</strong>",id:"setting-up-the-development-environment",level:3},{value:"<strong>Setting up Tailwind in Vue.js</strong>",id:"setting-up-tailwind-in-vuejs",level:3},{value:"<strong>Configuring routes</strong>",id:"configuring-routes",level:3},{value:"<strong>Installing Waku and its dependencies</strong>",id:"installing-waku-and-its-dependencies",level:3},{value:"<strong>Implementing Waku logic</strong>",id:"implementing-waku-logic",level:3},{value:"<strong>Implement Wallet Connect logic</strong>",id:"implement-wallet-connect-logic",level:3},{value:"<strong>Building the UI components</strong>",id:"building-the-ui-components",level:3},{value:"<strong>Creating polls</strong>",id:"creating-polls",level:3},{value:"<strong>Real-time voting and result polling</strong>",id:"real-time-voting-and-result-polling",level:3},{value:"<strong>Summary of the article</strong>",id:"summary-of-the-article",level:2}],c={toc:p};function d(e){let{components:t,...s}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("a",{href:"/es/build-dapps-using-waku"},(0,o.kt)(i.Button,{mdxType:"Button"},"Read in Spanish")),(0,o.kt)("br",null),(0,o.kt)("br",null),(0,o.kt)("p",null,"Did you know that far beyond being a mere industry buzzword, decentralised communication represents a strategic response to the vulnerabilities inherent in centralised systems? It prioritises privacy, security, and censorship resistance, making it an indispensable component in web developers' toolkits."),(0,o.kt)("p",null,"Traditional centralised communication systems have long struggled with censorship, single points of failure, and privacy concerns. With the rise of Web 3 and blockchain technology, decentralised communication solutions like Waku are emerging as a promising alternative. Waku offers a peer-to-peer messaging system that is resilient to censorship, scalable, and secure, making it an ideal choice for dApp developers looking to build next-generation applications."),(0,o.kt)("p",null,"This article will guide you on how to build a decentralised application (dApp) using Waku, an uncompromising decentralised communication protocol, and Vue.js, a popular JavaScript framework for building user interfaces. Before diving into the hands-on development aspects of this article, it is recommended that you have a basic understanding of Vue.js, familiarity with Tailwind CSS for UI styling, and a grasp of web3.js for seamless wallet integration."),(0,o.kt)("p",null,"If these technologies are new to you, no problem \u2013 this guide is meticulously created for all levels of expertise, providing step-by-step guidance at every level."),(0,o.kt)("h2",{id:"understanding-waku"},(0,o.kt)("strong",{parentName:"h2"},"Understanding Waku")),(0,o.kt)("p",null,"Waku is a collection of decentralised peer-to-peer messaging protocols that enable secure and censorship-resistant communication over a decentralised network. Its features include end-to-end encryption, persistent/ephemeral messaging, and efficient peer discovery, providing a foundation for secure and reliable communication."),(0,o.kt)("p",null,"Waku operates within a peer-to-peer topology, creating a decentralised network that thwarts censorship and provides surveillance resistance. Its design supports scalability, with the ability to accommodate millions of users. It is designed to be the successor of Whisper, the messaging layer of the Ethereum blockchain peer-to-peer protocol suite, and outperforms it in scalability and resource efficiency."),(0,o.kt)("p",null,"Waku's architecture is underpinned by three distinct network interaction domains: gossip, discovery, and request/response. Although Waku is a cohesive whole in terms of capabilities, it encompasses three primary clients designed for different environments and several SDKs, including Rust, React Native, Kotlin, and Swift."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"nwaku: The reference implementation in Nim."),(0,o.kt)("li",{parentName:"ol"},"go-waku: Tailored for native integration with Golang applications."),(0,o.kt)("li",{parentName:"ol"},"js-waku: A JavaScript implementation optimized for browser environments.")),(0,o.kt)("p",null,"Waku consists of multiple protocols, each serving a specific function within the network. They include, but are not limited to:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Waku Relay: The backbone of the Waku network, employing a pub/sub approach to peer-to-peer messaging. Emphasizes privacy, censorship resistance, and security, extending the libp2p GossipSub protocol."),(0,o.kt)("li",{parentName:"ul"},"Waku Filter: A lightweight version of the relay protocol designed for resource-restricted devices. Allows light nodes to receive specific messages of interest from full nodes."),(0,o.kt)("li",{parentName:"ul"},"Waku Store: Facilitates message retrieval for devices unable to participate in the Waku Relay network while offline."),(0,o.kt)("li",{parentName:"ul"},"Waku Light Push: A request/response protocol enabling nodes with short connection windows or limited bandwidth to publish messages to the Waku network.")),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"alt_text",src:n(56288).Z,width:"813",height:"642"})),(0,o.kt)("p",null,"Understanding Waku's architecture and protocols lays the groundwork for proceeding into practical implementations."),(0,o.kt)("h2",{id:"use-cases-of-waku"},(0,o.kt)("strong",{parentName:"h2"},"Use cases of Waku")),(0,o.kt)("p",null,"Waku's versatile architecture and capabilities find relevance in a myriad of real-world scenarios where secure and decentralised communication is paramount. Whether it's facilitating private conversations between users, enabling data exchange between devices, or supporting communication among nodes within a network, Waku emerges as a robust solution."),(0,o.kt)("h4",{id:"privacy-focused-communication"},(0,o.kt)("strong",{parentName:"h4"},"Privacy-focused communication")),(0,o.kt)("p",null,"Waku's emphasis on privacy makes it an ideal choice for scenarios where safeguarding user information is of utmost importance. In applications dealing with sensitive data or confidential conversations, Waku's end-to-end encryption and decentralised architecture provide a secure environment, mitigating the risks associated with centralised communication platforms."),(0,o.kt)("h4",{id:"censorship-resistant-messaging"},(0,o.kt)("strong",{parentName:"h4"},"Censorship-resistant messaging")),(0,o.kt)("p",null,"Waku offers a beacon of hope for unrestricted communication in regions where internet censorship is prevalent. Its peer-to-peer topology prevents centralised authorities from controlling or monitoring messaging traffic, ensuring that users can communicate freely without fear of censorship. This makes Waku particularly valuable in promoting freedom of expression and supporting open communication channels."),(0,o.kt)("h4",{id:"use-in-dapps-for-decentralised-communication"},(0,o.kt)("strong",{parentName:"h4"},"Use in dApps for decentralised communication")),(0,o.kt)("p",null,"Decentralised applications (DApps) form a burgeoning ecosystem where Waku can play a pivotal role. Waku's integration into dApps enhances communication functionalities, enabling real-time interactions among users while maintaining the decentralised ethos. This proves particularly valuable in scenarios such as collaborative platforms, social networks, or any application where user engagement and communication are central components."),(0,o.kt)("p",null,"By exploring the features and capabilities of Waku, it becomes evident that Waku's applicability extends beyond theoretical advantages, finding practical application in diverse areas."),(0,o.kt)("h2",{id:"building-a-dapp-with-waku-and-vuejs"},(0,o.kt)("strong",{parentName:"h2"},"Building a dApp with Waku and Vue.js")),(0,o.kt)("p",null,"Polling systems often face challenges related to centralisation, privacy concerns, and susceptibility to manipulation. By integrating Waku and Vue.js, we can tackle these challenges, creating a decentralised voting poll application that leverages the power of peer-to-peer communication."),(0,o.kt)("p",null,"Here is the entire source code of my voting poll app on GitHub: ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/wolz-CODElife/waku-vue-poll.git"},"https://github.com/wolz-CODElife/waku-vue-poll.git")," and the ",(0,o.kt)("a",{parentName:"p",href:"https://waku-vue-poll.vercel.app/"},"live application")," is hosted on Vercel."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"alt_text",src:n(12673).Z,width:"1600",height:"962"})),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"alt_text",src:n(23461).Z,width:"1600",height:"962"})),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"alt_text",src:n(56820).Z,width:"1600",height:"962"})),(0,o.kt)("h3",{id:"dev-tools-i-used"},(0,o.kt)("strong",{parentName:"h3"},"Dev tools I used?")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Vite: To bootstrap the Vue3 application with the Tailwind template."),(0,o.kt)("li",{parentName:"ul"},"Vue 3: To build the user interface."),(0,o.kt)("li",{parentName:"ul"},"TypeScript: For type safety and potential for catching errors during compiling."),(0,o.kt)("li",{parentName:"ul"},"Tailwind CSS: For styling the user interface."),(0,o.kt)("li",{parentName:"ul"},"Web3.js: For implementing wallet connect."),(0,o.kt)("li",{parentName:"ul"},"Node Polyfill Webpack Plugin: For providing polyfills necessary for emitting Web3.js events in the browser. Since Vue3 uses webpack v5, where polyfill Node core modules were removed."),(0,o.kt)("li",{parentName:"ul"},"Crypto Hash: For hashing user address, where wallet is not available."),(0,o.kt)("li",{parentName:"ul"},"Protobufjs: For serializing message data sent through Waku."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"@waku/sdk"),": For accessing Waku node methods in JavaScript.")),(0,o.kt)("h3",{id:"setting-up-the-development-environment"},(0,o.kt)("strong",{parentName:"h3"},"Setting up the development environment")),(0,o.kt)("p",null,"To set up your development environment, ensure you have Node v18+ then open a new terminal in your working directory and run the following command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"npm create vite@latest\n")),(0,o.kt)("p",null,"Which will begin a dialogue in the terminal, you can choose options that work for you, or use the same options as I used:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"Need to install the following packages:\n  create-vite@5.1.0\nOk to proceed? (y) y\n\u2714 Project name: \u2026 waku-poll-app\n\u2714 Select a framework: \u203a Vue\n\u2714 Select a variant: \u203a TypeScript\n")),(0,o.kt)("p",null,"This should create a new Vue application in your working directory, navigate to the app, install the default dependencies and start the app using the following command:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"cd waku-poll-app\nnpm install\nnpm run dev\n")),(0,o.kt)("p",null,"Next, we want to create a file structure that allows us to componentize the various parts of the app. Your ",(0,o.kt)("inlineCode",{parentName:"p"},"src")," path should have a file structure like this:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"alt_text",src:n(62894).Z,width:"530",height:"302"})),(0,o.kt)("p",null,"As we proceed we will update files with the necessary code, as for ",(0,o.kt)("inlineCode",{parentName:"p"},"assets/3dpoll.jpg")," feel free to replace it with any image you see fit for your landing page."),(0,o.kt)("h3",{id:"setting-up-tailwind-in-vuejs"},(0,o.kt)("strong",{parentName:"h3"},"Setting up Tailwind in Vue.js")),(0,o.kt)("p",null,"To build our UI, we need to first install and configure Tailwind CSS in Vue 3. You can follow the official guide on ",(0,o.kt)("a",{parentName:"p",href:"https://v2.tailwindcss.com/docs/guides/vue-3-vite#setting-up-tailwind-css"},"Setting up Tailwind CSS"),"."),(0,o.kt)("h3",{id:"configuring-routes"},(0,o.kt)("strong",{parentName:"h3"},"Configuring routes")),(0,o.kt)("p",null,"To create multiple pages/routes in the app, we have to install Vue Router by running the following command in the terminal:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"npm install --save vue-router@next \n# Install the latest version\n")),(0,o.kt)("p",null,"In this app, we just need two routes: \u201cHome\u201d and \u201cPolls\u201d which we have inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"src/views")," folder. These routes will contain the Layout of each page, and then we can define the routes in the ",(0,o.kt)("inlineCode",{parentName:"p"},"src/router/index.ts")," file by using the following code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"import { createRouter, createWebHistory, RouteRecordRaw } from 'vue-router'\nimport Home from '@/views/Home.vue'\n\nconst routes: Array<RouteRecordRaw> = [\n  {\n    path: '/',\n    name: 'Home',\n    component: Home,\n  },\n  {\n    path: '/polls',\n    name: 'Polls',\n\n    component: () => import('../views/Polls.vue'),\n  }\n]\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes,\n})\n\nexport default router\n")),(0,o.kt)("p",null,"In the code snippet above, a Vue.js router configuration is defined. We import the necessary functions and types from 'vue-router' and the Home component from ",(0,o.kt)("inlineCode",{parentName:"p"},"@/views/Home.vue"),"."),(0,o.kt)("p",null,"The routes array contains route definitions for the Home and Polls components. The router is created using createRouter and createWebHistory functions, and the routes we defined earlier."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"component: () => import('../views/Polls.vue')")," is used to dynamically import the 'Polls.vue' component. This is a feature provided by Vue.js to asynchronously load the component when it's needed, which can help improve initial page load performance by splitting the code into smaller chunks."),(0,o.kt)("p",null,"Finally, the router is exported so we can access it in \u201cmain.ts\u201d."),(0,o.kt)("p",null,"Next, we register ",(0,o.kt)("inlineCode",{parentName:"p"},"router")," to the Vue app by including it in the \u201cmain.ts\u201d file like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// main.ts or main.js\nimport { createApp } from 'vue';\nimport App from './App.vue';\nimport './css/index.css'\n\nimport router from './router'\n\ncreateApp(App).use(router).mount('#app')\n")),(0,o.kt)("p",null,"Next, we will create a Layout for our application with the following inside \u201cApp.vue\u201d:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'<script lang="ts">\n<\/script>\n\n\n<template>\n  <div class="flex flex-col h-screen justify-between">\n    <router-view class="container max-w-8xl mx-auto mb-auto px-4" />\n  </div>\n</template>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  color: #2c3e50;\n}\n</style>\n')),(0,o.kt)("p",null,"In the code above, we use ",(0,o.kt)("inlineCode",{parentName:"p"},"router-view")," to dynamically load the components of the current route into the DOM."),(0,o.kt)("h3",{id:"installing-waku-and-its-dependencies"},(0,o.kt)("strong",{parentName:"h3"},"Installing Waku and its dependencies")),(0,o.kt)("p",null,"To get started with Waku in our Vue 3 application, we need to install ",(0,o.kt)("inlineCode",{parentName:"p"},"@waku/sdk")," which is a TypeScript implementation of the Waku protocol designed for web browser environments."),(0,o.kt)("p",null,"To install ",(0,o.kt)("inlineCode",{parentName:"p"},"@waku.sdk")," run the following command in the terminal:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"npm install @waku/sdk\n")),(0,o.kt)("p",null,"It is also recommended to create a message structure for your app, typically Waku developers use ",(0,o.kt)("a",{parentName:"p",href:"https://protobuf.dev/"},"Protocol Buffers")," for consistency, interoperability, compatibility and payload size. To install ",(0,o.kt)("inlineCode",{parentName:"p"},"protobufjs"),", run the following command in the terminal:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"npm install protobufjs\n")),(0,o.kt)("h3",{id:"implementing-waku-logic"},(0,o.kt)("strong",{parentName:"h3"},"Implementing Waku logic")),(0,o.kt)("p",null,"The application runs on two fundamental logic, which are the wallet connect and Waku communication integrations. We will create two composables \u201cwaku.ts\u201d and \u201cclient.ts\u201d inside ",(0,o.kt)("inlineCode",{parentName:"p"},"src/composables"),"."),(0,o.kt)("p",null,"\u201cwaku.ts\u201d contains all the methods our Vue app needs to interact with the Waku protocol and transmit messages(polls) across users on the app. Inside this file, you should have the following code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"import { ref } from 'vue';\nimport protobuf, { Message } from 'protobufjs';\nimport {\n    createLightNode,\n    waitForRemotePeer,\n    createDecoder,\n    createEncoder,\n    Protocols,\n    IFilterSubscription,\n} from '@waku/sdk';\n\ninterface PollOption {\n    value: string;\n    votes: number;\n}\n\ninterface PollMessage {\n    question: string;\n    options: { [key: string]: PollOption };\n}\n\ninterface Poll {\n    msgid: string;\n    timestamp: string;\n    sender: string;\n    message: PollMessage;\n    // other properties...\n}\n\n\nexport const status = ref<string>('connecting...');\nexport const sender = ref(localStorage.getItem('senderWalletAddress') ?? '');\nexport const polls = ref<Poll[]>(JSON.parse(localStorage.getItem('polls') ?? '[]'));\n\n\nexport const wakuNode = await createLightNode({\n    defaultBootstrap: true,\n});\n\nexport const waitForRemotePeers = async () => {\n    // Wait for a successful peer connection\n    await waitForRemotePeer(wakuNode, [\n        Protocols.LightPush,\n        Protocols.Filter,\n    ]);\n}\n\n// Choose a content topic\nexport const contentTopic = '/waku-vue-poll/1/polls/proto';\n\n// message encoder and decoder\nexport const encoder = createEncoder({ contentTopic, ephemeral: true });\nexport const decoder = createDecoder(contentTopic);\n\n// Message structure with Protobuf\nexport const PollQuestionWakuMessage = new protobuf.Type('PollQuestion')\n    .add(new protobuf.Field('timestamp', 1, 'string'))\n    .add(new protobuf.Field('msgid', 2, 'string'))\n    .add(new protobuf.Field('sender', 3, 'string'))\n    .add(new protobuf.Field('message', 4, 'string'));\n\nexport const serializeMessage = (protoMessage: Message) => {\n    return PollQuestionWakuMessage.encode(protoMessage).finish()\n}\n\nexport function useWaku() {\n\n    async function start() {\n        status.value = 'connecting'        \n        try {\n            await wakuNode?.start().then(() => {\n                if (wakuNode.isStarted()) return waitForRemotePeers()\n            }).then(() => {\n                return wakuNode.connectionManager.getPeersByDiscovery()\n            }).then((data:any) => {\n                if (\n                    wakuNode.libp2p.getConnections().length ||\n                    data.CONNECTED.bootstrap.length ||\n                    data.CONNECTED['peer-exchange'].length\n                ) {\n                    subscribe()\n                    status.value = \"connected\"\n                }\n            })\n        }\n        catch (error) {\n            console.error('Error initializing Waku Light Node:', error);\n            status.value = 'not connected';\n        }\n    }\n\n    async function stop() {\n        unsubscribe();\n        wakuNode.stop()\n        status.value = 'not conencted';\n    }\n    let subscription = {} as IFilterSubscription\n\n    async function subscribe() {\n        if (!wakuNode || status.value !== 'connected') await start();\n        try {\n          subscription = await wakuNode?.filter?.createSubscription();\n          await subscription.subscribe([decoder], (wakuMessage) => {\n            const messageObj = PollQuestionWakuMessage.decode(wakuMessage.payload).toJSON();\n            const result: Poll = {\n                timestamp: messageObj.timestamp,\n                msgid: messageObj.msgid,\n                sender: messageObj.sender,\n                message: JSON.parse(messageObj.message ?? '{}')\n            };\n            handleSubscriptionResult(result);\n          });\n        } catch (error) {\n          console.error('Error subscribing to Content Topic:', error);\n        }\n      }\n\n      function handleSubscriptionResult(result:Poll) {\n        const msgid = result.msgid;\n        const existingPollIndex = polls.value.findIndex(poll => poll.msgid === msgid);\n\n        if (existingPollIndex !== -1) {\n          // Update the existing poll\n          polls.value.splice(existingPollIndex, 1, result);\n        } else {\n          // Add the new poll to the array\n          polls.value.unshift(result);\n        }\n\n        if (polls.value.length > 0) {\n            localStorage.setItem('polls', JSON.stringify(polls.value));\n        }\n      }\n\n    async function unsubscribe() {\n        subscription.unsubscribe([contentTopic])\n    }\n\n    async function publish(sender: string, message: string, timestamp: string = new Date().toUTCString(), msgid: string = Date.now() + Math.floor(Math.random() * 90000).toString()) {    \n        if (!wakuNode || status.value !== 'connected') await start()\n\n        try {\n            const protoData = PollQuestionWakuMessage.create({\n                timestamp: timestamp,\n                msgid: msgid,\n                sender: sender,\n                message: message\n            })\n\n            return wakuNode.lightPush.send(encoder, { payload: serializeMessage(protoData) })\n        }\n        catch (error) {\n            console.error('Error publishing to Content Topic:', error);\n        }\n    }\n\n    return {\n        wakuNode,\n        status,\n        sender,\n        polls,\n        start,\n        stop,\n        subscribe,\n        unsubscribe,\n        publish,\n    };\n}\n")),(0,o.kt)("p",null,"The above code enables interaction with the Waku network, enabling the creation and participation in polls within a Vue application."),(0,o.kt)("p",null,"Firstly, we import necessary functions and define data structure using TypeScript interfaces to set a standard for PollOption, PollMessage and Poll. These structures represent the questions and options available in a poll and the overall structure of a poll, respectively."),(0,o.kt)("p",null,"Reactive variables (status, sender, and polls) are defined to keep track of the connection status, the sender's information, and the list of polls. These variables will be necessary for updating the Vue application in response to changes in the Waku network."),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Notice that we didn\u2019t make WakuNode or any variable interacting with the Waku network directly reactive. As this will trigger ",(0,o.kt)("a",{parentName:"em",href:"https://github.com/waku-org/js-waku/issues/1746"},"issue #1746")," due to Waku nodes being too complex for Vue mechanisms to handle, so we have to keep the WakuNode instance outside Vue\u2019s reactive scope.")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"BTW, this took me almost 3 months to figure out \ud83d\ude2d")),(0,o.kt)("p",null,"The WakuNode connection is established using the createLightNode function, optimizing resource usage by creating a Waku light node. This node connects to the Waku network and waits for peers to join using the ",(0,o.kt)("a",{parentName:"p",href:"https://rfc.vac.dev/spec/19/"},"LightPush")," and ",(0,o.kt)("a",{parentName:"p",href:"https://rfc.vac.dev/spec/12/"},"Filter")," Protocols. We defined a specific ",(0,o.kt)("a",{parentName:"p",href:"https://docs.waku.org/learn/concepts/content-topics"},"Content Topic")," for this app to categorize messages and should have this format, ",(0,o.kt)("inlineCode",{parentName:"p"},"/{application-name}/{version}/{content-topic-name}/{encoding}"),", make sure to replace ",(0,o.kt)("inlineCode",{parentName:"p"},"WAKU_CONTENT_TOPIC")," with your actual Content Topic. and Protobuf is utilized for encoding and decoding messages efficiently to suit the ",(0,o.kt)("inlineCode",{parentName:"p"},"PollQuestionWakuMessage")," message structure."),(0,o.kt)("p",null,"After connecting to the Waku network, interaction follows. We created a function called useWaku() that encapsulates and returns all the variables and methods needed to interact with Waku across the entire application."),(0,o.kt)("p",null,"First, we have the ",(0,o.kt)("inlineCode",{parentName:"p"},"start()")," function that initiates the WakuNode connection, waits for peers to connect and subscribes to the chosen content topic, before updating the user\u2019s status to ",(0,o.kt)("inlineCode",{parentName:"p"},'status.value = "connected"'),"."),(0,o.kt)("p",null,"Next, we have ",(0,o.kt)("inlineCode",{parentName:"p"},"stop()")," function that unsubscribes from the Content Topic and stops the WakuNode, before updating the user\u2019s status to ",(0,o.kt)("inlineCode",{parentName:"p"},"status.value = 'not conencted'"),"."),(0,o.kt)("p",null,"Next, we have the ",(0,o.kt)("inlineCode",{parentName:"p"},"subscribe()")," function that creates a subscription to the Content Topic using the Waku Filter, receives incoming poll messages, decodes them and updates the polls list. The handleSubscriptionResult function decodes incoming poll messages, checks for duplicates, and updates the list of polls accordingly."),(0,o.kt)("p",null,"Next, we have the ",(0,o.kt)("inlineCode",{parentName:"p"},"unsubscribe()")," function that disconnects the app from the Content Topic."),(0,o.kt)("p",null,"Finally, the ",(0,o.kt)("inlineCode",{parentName:"p"},"publish()")," function accepts the necessary parameters to create a new poll message and send the encoded poll message to the Waku network using the LightPush protocol."),(0,o.kt)("h3",{id:"implement-wallet-connect-logic"},(0,o.kt)("strong",{parentName:"h3"},"Implement Wallet Connect logic")),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"sender")," variable in the \u201cwaku.ts\u201d composable stores the wallet address of the connected wallet. For us to implement wallet connect, we need to first install \u201cWeb3.js\u201d by running the following command in the terminal:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"npm install web3\n")),(0,o.kt)("p",null,"Since Vue 3 uses webpack v5, we need to install Node Polyfill Webpack Plugin to provide the polyfills necessary for emitting Web3.js events in the browser. Run the following command in the terminal to install the Node Polyfill Webpack Plugin:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"npm i node-polyfill-webpack-plugin\n")),(0,o.kt)("p",null,"Then include it in the \u201cvite.config.ts\u201d so that your \u201cvite.config.ts\u201d looks like this:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"import { defineConfig } from 'vite';\nimport vue from '@vitejs/plugin-vue';\nimport path from 'path';\n\n// https://vitejs.dev/config/\nexport default defineConfig({\n  plugins: [vue()],\n  resolve: {\n    alias: {\n      '@/': `${path.resolve(__dirname, 'src')}/`,\n    },\n  },\n  optimizeDeps: {\n    include: ['node-polyfill-webpack-plugin'],\n  },\n  esbuild: {\n    supported: {\n      'top-level-await': true\n    }\n  }\n});\n")),(0,o.kt)("p",null,"You will notice we are also supporting ",(0,o.kt)("inlineCode",{parentName:"p"},"top-level-await"),", this is because we are instantiating WakuNode at a top-level and the Vite build doesn\u2019t support this."),(0,o.kt)("p",null,"Inside the \u201cclient.ts\u201d we will have the following code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"import Web3 from 'web3';\nimport { useWaku } from './waku';\nimport { sha256 } from 'crypto-hash';\n\ndeclare global {\n    interface Window {\n        ethereum: any;\n        web3: any\n    }\n}\n\nconst waku = useWaku()\nexport const generateUniqueID = () => {\n    const userAgentHash = sha256(navigator.userAgent + Math.floor(Math.random() * 90000));\n  return userAgentHash;\n};\n\n// Validate Ethereum Address\nexport const validateEthereumAddress = (address:any) => {\n    return /^(0x)?[0-9a-fA-F]{40}$/.test(address);\n}\n\nexport function useWalletConnect() {\n    // Improved connectWallet Function\n    async function connectWallet() {\n        if (window.ethereum) {\n            try {\n                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });\n                window.web3 = new Web3(window.ethereum);\n\n                if (accounts.length > 0 && validateEthereumAddress(accounts[0])) {\n                    const walletAddress = accounts[0];\n                    waku.sender.value = walletAddress;\n                    localStorage.setItem('senderWalletAddress', walletAddress);\n                } else {\n                    console.error('Invalid Ethereum address detected. Generating fallback ID.');\n                    generateUniqueID().then((hashID) => {\n                        const newHash = 'abcdef012345'[Math.floor(Math.random() * 12)] + \"x\" + hashID.slice(-20);\n                        waku.sender.value = newHash;\n                        localStorage.setItem('senderWalletAddress', newHash);\n                    });\n                }\n\n                await waku.start();\n            } catch (error) {\n                console.error('Error connecting wallet:', error);\n            }\n        } else {\n            console.log('No Ethereum wallet detected.');\n        }\n    }\n\n\n    async function disconnectWallet() {\n        localStorage.removeItem('senderWalletAddress');\n        localStorage.removeItem('polls');\n        // stop waku's light node\n        await waku.wakuNode.stop();\n        waku.stop()\n        waku.sender.value = \"\"\n        waku.status.value = \"connecting...\"\n        waku.polls.value = []\n    }\n    async function signMessage(msgid: string, stringifiedMessage:string) {\n        const messageToSign = `Message ID: ${msgid}, Content: ${stringifiedMessage}`;\n        let signature;\n        try {\n            signature = await window.ethereum.request({\n                method: 'personal_sign',\n                params: [messageToSign, waku.sender.value],\n            });\n            return signature\n        } catch (signError) {\n            console.error('Error signing the message:', signError);\n            return;\n        }\n    }\n\n    return {\n        connectWallet,\n        disconnectWallet,\n        signMessage\n    };\n}\n")),(0,o.kt)("p",null,"The above code enables users to connect their crypto wallet to the app as a means of identification. In this scenario, we used the wallet address as the sender of the poll."),(0,o.kt)("p",null,"However, some users may not have wallets and we don\u2019t want to limit the application to only users that have crypto wallets. To tackle this, we created the ",(0,o.kt)("inlineCode",{parentName:"p"},"generateUniqueID()")," function to form a random hash from the ",(0,o.kt)("inlineCode",{parentName:"p"},"navigator.userAgent")," address of the user\u2019s browser. Then we store the sender\u2019s address in localStorage as \u201c'senderWalletAddress'\u201d."),(0,o.kt)("p",null,"We also created a ",(0,o.kt)("inlineCode",{parentName:"p"},"disconnectWallet()")," function to remove the wallet address from localStorage and stop the WakuNode running."),(0,o.kt)("p",null,"To claim ownership of the polls, users have to sign each poll message using their wallet, for this the ",(0,o.kt)("inlineCode",{parentName:"p"},"signMessage")," function is executed."),(0,o.kt)("p",null,"The ",(0,o.kt)("inlineCode",{parentName:"p"},"useWalletConnect")," composable encapsulates and returns the ",(0,o.kt)("inlineCode",{parentName:"p"},"connectWallet"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"disconnectWallet")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"signMessage")," functions so that they are accessible across the application."),(0,o.kt)("h3",{id:"building-the-ui-components"},(0,o.kt)("strong",{parentName:"h3"},"Building the UI components")),(0,o.kt)("p",null,"Now that we have our logic, we can build the UI to utilize the data and methods in our composables."),(0,o.kt)("p",null,"We have 3 major components in this app, the ",(0,o.kt)("inlineCode",{parentName:"p"},"NavBar"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Home")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"Polls"),". Feel free to create your user interface or use mine:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/wolz-CODElife/waku-vue-poll/blob/master/src/components/NavBar.vue"},"NavBar"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"src/components/NavBar.vue")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/wolz-CODElife/waku-vue-poll/blob/master/src/views/Home.vue"},"Home"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"src/views/Home.vue")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/wolz-CODElife/waku-vue-poll/blob/master/src/views/Polls.vue"},"Polls"),": ",(0,o.kt)("inlineCode",{parentName:"li"},"src/views/.vue"))),(0,o.kt)("h3",{id:"creating-polls"},(0,o.kt)("strong",{parentName:"h3"},"Creating polls")),(0,o.kt)("p",null,"If you go through my NavBar component code, you will find that we have a ",(0,o.kt)("inlineCode",{parentName:"p"},"ref")," called poll:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'const poll = ref<Poll>({\n  question: "",\n  options: {\n    a: { value: "", votes: 0},\n    b: { value: "", votes: 0},\n    c: { value: "", votes: 0},\n    d: { value: "", votes: 0},\n    e: { value: "", votes: 0}\n  }\n})\n')),(0,o.kt)("p",null,"This ",(0,o.kt)("inlineCode",{parentName:"p"},"ref")," is updated by the modal form, and on submit, we trigger the ",(0,o.kt)("inlineCode",{parentName:"p"},"sendMessage")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},'const sendMessage = () => {\n  const stringifiedMessage = JSON.stringify(poll.value)\n  const msgid = Date.now() + Math.floor(Math.random() * 90000).toString();\n  const timestamp = new Date().toUTCString()\n\n  // sign message\n  signMessage(msgid, stringifiedMessage).then((signature) => {\n    // send a message\n    waku.publish(signature, stringifiedMessage, timestamp, msgid)\n\n    // reset question state\n    poll.value = {\n      question: "",\n      options: {\n        a: { value: "", votes: 0},\n        b: { value: "", votes: 0},\n        c: { value: "", votes: 0},\n        d: { value: "", votes: 0},\n        e: { value: "", votes: 0}\n      }\n    }\n    }\n    onToggle()\n    // redirect user to where the new poll is populated\n    if (router.currentRoute.value.path !== "/polls") {\n      router.push("/polls")\n    }\n  }).catch((error) => {\n    console.error("Error sending message", error);\n  })\n}\n')),(0,o.kt)("p",null,"In the above code, we stringify the poll data which includes the question, and options so that we can publish the poll as a message to Waku. Then we create a ",(0,o.kt)("inlineCode",{parentName:"p"},"msgid")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"timestamp")," for the message, before using the user's wallet to sign the message. Once the message is signed, we call the ",(0,o.kt)("inlineCode",{parentName:"p"},"waku.publish(waku.sender.value, stringifiedMessage)")," function to register the update for other users subscribing to the Content Topic."),(0,o.kt)("h3",{id:"real-time-voting-and-result-polling"},(0,o.kt)("strong",{parentName:"h3"},"Real-time voting and result polling")),(0,o.kt)("p",null,"In the \u201cPoll.vue\u201d component, we have a ",(0,o.kt)("inlineCode",{parentName:"p"},"handleVote()")," function:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"const handleVote = async (msgid: string, selectedOption: string | number) => {\n  loading.value = true\n  try {\n    // Find the selected poll in the polls array\n    let selectedPollIndex = waku.polls.value.findIndex((poll) => poll.msgid === msgid);\n\n    if (selectedPollIndex !== -1) {\n      // Update the vote count before publishing\n      waku.polls.value[selectedPollIndex].message.options[selectedOption].votes += 1;\n\n      // Create a reactive copy to trigger reactivity\n      const reactiveCopy = reactive({ ...waku.polls.value[selectedPollIndex] });\n\n      // Publish the updated poll\n\n      const stringifiedMessage = JSON.stringify(reactiveCopy.message);\n\n      await waku.publish(reactiveCopy.sender , stringifiedMessage, reactiveCopy.timestamp, msgid);\n\n      // Store the msgid in local storage\n      votedPolls.value.push(msgid);\n      localStorage.setItem('votedPolls', JSON.stringify(votedPolls.value));\n    }\n    loading.value = false\n  } catch (error) {\n    console.error('Error in handleVote:', error);\n  }\n};\n")),(0,o.kt)("p",null,"This function is triggered when the radio input of any option is clicked. This function collected the ",(0,o.kt)("inlineCode",{parentName:"p"},"msgid")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"selectedOption")," as parameters. Then call the ",(0,o.kt)("inlineCode",{parentName:"p"},"subscribe()")," function to fetch the latest version of the polls, before updating the vote counts of an option in the poll that has the ",(0,o.kt)("inlineCode",{parentName:"p"},"msgid"),"."),(0,o.kt)("p",null,"We created a reactive copy of the poll so that the vote count update will be reflected even if the state changes. Then we publish the reactive copy, which will send the updated poll results to all the users that are subscribed to the Content Topic of this app."),(0,o.kt)("p",null,"To track the polls a user has voted for, we store a \u201cvotePolls\u201d array in the localStorage."),(0,o.kt)("p",null,"Feel free to play around with the functionality and optimize the performance to meet your application requirements."),(0,o.kt)("h2",{id:"summary-of-the-article"},(0,o.kt)("strong",{parentName:"h2"},"Summary of the article")),(0,o.kt)("p",null,"In this comprehensive guide, we embarked on a journey to integrate Waku, a decentralised communication protocol, into a Vue.js application, creating a real-time voting poll dApp. Let's recap the key takeaways from the guide:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Understanding Waku",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Explored Waku as a family of protocols facilitating private, censorship-resistant communications over a decentralised network."),(0,o.kt)("li",{parentName:"ul"},"Examined Waku's features, architecture, and its focus on privacy, decentralisation, and adaptability to various platforms."),(0,o.kt)("li",{parentName:"ul"},"Discussed the different components of Waku, such as Waku Relay, Waku Filter, Waku Store, and Waku Light Push."))),(0,o.kt)("li",{parentName:"ul"},"Use Cases of Waku",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Discussed real-world scenarios where Waku proves invaluable, emphasizing its role in privacy-focused communication, censorship-resistant messaging, and decentralised communication within dApps."))),(0,o.kt)("li",{parentName:"ul"},"Building a dApp with Waku and Vue.js",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"Set up a Vue.js application using Vite and Tailwind CSS."),(0,o.kt)("li",{parentName:"ul"},"Established a connection to the Waku network, implemented wallet authentication using Web3.js, and integrated the ",(0,o.kt)("inlineCode",{parentName:"li"},"@waku/sdk")," for decentralised communication."),(0,o.kt)("li",{parentName:"ul"},"Demonstrated the step-by-step process of building a real-time voting poll, connecting to the Waku network.")))),(0,o.kt)("p",null,"As you conclude this guide, consider taking the following actions to further explore and experiment with Waku:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Waku Documentation"),": Visit the ",(0,o.kt)("a",{parentName:"li",href:"https://docs.waku.org/"},"Waku documentation")," to delve deeper into the functionalities, protocols, and use cases of Waku."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Experiment with Additional Functionalities"),": Extend the capabilities of your dApp by experimenting with additional functionalities provided by Waku. Explore features like ephemeral messaging, decentralised storage, and more to enhance your DApps."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Join the Waku Community"),": Engage with the ",(0,o.kt)("a",{parentName:"li",href:"https://waku.org/community/"},"Waku community")," on forums, social media, or developer channels. Connect with like-minded developers, share your experiences, and stay updated on the latest developments within the Waku ecosystem."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Contribute to Waku"),": Consider ",(0,o.kt)("a",{parentName:"li",href:"https://waku.org/about/team"},"contributing")," to the Waku project on platforms like GitHub. Whether it's reporting issues, submitting pull requests, or suggesting improvements, your contributions can play a vital role in the growth of this decentralised communication protocol.")))}d.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=u(n),m=o,h=d["".concat(l,".").concat(m)]||d[m]||c[m]||i;return n?a.createElement(h,s(s({ref:t},p),{},{components:n})):a.createElement(h,s({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,s=new Array(i);s[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,s[1]=r;for(var u=2;u<i;u++)s[u]=n[u];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},12673:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image-1-e2a7b7d5732a81ee34cd4082ae446b24.png"},23461:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image-2-480c17eca69dabecd311787534ce0896.png"},56820:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image-3-241d73cb8b5146a6c23ac036feafb8b1.png"},62894:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/image-4-378edf5f6f6fea4f6eb7fd5100c74a7d.png"},56288:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/waku-relay-shards-d61c1adfaa0d788d99babdcf885da9ba.png"}}]);